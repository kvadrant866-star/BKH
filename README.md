Пример .env файла
APP_NAME=banner_service
HOST=0.0.0.0
PORT=8080

FLUSH_INTERVAL=1
NUM_SHARDS=64

DB_HOST=${APP_NAME}_DB
DB_PORT=5432
DB_NAME=banner
DB_USER=postgres
DB_PASSWORD=postgres


Запуск:
docker compose up --build -d

Как работает сервис
- Горячий путь /counter/{id}: инкремент счётчика происходит в оперативной памяти. Ключ бакета — пара (bannerID, minute), где minute = текущая метка времени, округлённая вниз до минуты (UTC). Для снижения конкуренции используются шардированные мапы; число шардов настраивается переменной NUM_SHARDS.
- Фоновый флашер: каждые FLUSH_INTERVAL секунд агрегированные значения сбрасываются батчем в Postgres через INSERT ... ON CONFLICT (banner_id, minute_ts) DO UPDATE SET count = count + EXCLUDED.count. Это делает запись идемпотентной и конкурентно‑безопасной.
- Чтение /stats/{id}: по диапазону [from, to] выбираются минутные бакеты из таблицы, сортируются по времени и отдаются в формате {ts, v}. Контроллер принимает и возвращает время в формате YYYY‑MM‑DDTHH:MM:SS, внутри всё хранится в UTC.

ВАЖНО
- Внутри сервиса все вычисления и хранение ведутся в UTC (minute_ts = UTC, округлено до минуты). Если локальное время вашей машины отличается по зоне (например, Europe/Moscow), то момент клика будет записан в близкую по значению минуту, но в UTC. Поэтому при запросе статистики указывайте диапазон в UTC (или закладывайте поправку на свою временную зону). Например, локальное 22:00 MSK соответствует 19:00 UTC.